import numpy as np
import matplotlib.pyplot as plt
from pypower.api import runpf, case30
from pyswarm import pso

# List to store power losses for each iteration
losses = []

def power_losses(x):
    """ Objective function to compute power losses. """
    
    # Load the case30 system
    ppc = case30()
    
    # Update the generator real power outputs
    ppc['gen'][:, 1] = x[:ppc['gen'].shape[0]]
    ppc['gen'][:, 2] = x[ppc['gen'].shape[0]:]

    # Run a power flow
    result, _ = runpf(ppc)
    
    # Check constraints
    # Bus voltage limits
    V = result['bus'][:, 7]
    Vmin = ppc['bus'][:, 12]
    Vmax = ppc['bus'][:, 11]
    # if any(V < Vmin) or any(V > Vmax):
    #     losses.append(1e10)  # Append penalty to the list
    #     return 1e10  # Large penalty for voltage constraint violation
    
    # Transmission capacity limits
    flow = np.abs(result['branch'][:, 13:15]).sum(axis=1)
    capacity = ppc['branch'][:, 5]
    # if any(flow > capacity):
    #     losses.append(1e10)  # Append penalty to the list
    #     return 1e10  # Large penalty for transmission constraint violation
    
    # Compute the total power loss in the system
    loss = sum(result['branch'][:, 13] + result['branch'][:, 14])
    
    # Append the loss to the list
    losses.append(loss)
    return loss

# Get the generator limits from the case30 system
ppc = case30()
Pgen_min = ppc['gen'][:, 9]
Pgen_max = ppc['gen'][:, 8]
Qgen_min = ppc['gen'][:, 4]
Qgen_max = ppc['gen'][:, 3]

# Use PSO to minimize the power losses
lb = np.concatenate([Pgen_min, Qgen_min])
ub = np.concatenate([Pgen_max, Qgen_max])

xopt, fopt = pso(power_losses, lb, ub)

print("Optimal generator outputs (P and Q): ", xopt)
print("Minimum power losses: ", fopt)

# Plotting the losses across iterations
plt.figure(figsize=(10, 6))
plt.plot(losses, '-o')
plt.title('Power Losses across Iterations')
plt.xlabel('Iteration')
plt.ylabel('Power Losses (or Penalty Value)')
plt.grid(True)
plt.show()
